@page "/shop"
@using MaillotStore.Components.Account.Shared
@using MaillotStore.Models
@using MaillotStore.Data
@using MaillotStore.Services
@using Microsoft.EntityFrameworkCore
@rendermode InteractiveServer
@inject ApplicationDbContext DbContext
@inject SearchStateService SearchState
@implements IDisposable

<PageTitle>Shop</PageTitle>

@* UPDATED: Added px-1 for mobile to stretch content closer to edges, keeping px-md-3 for desktop *@
<div class="container mt-4 px-1 px-md-3">
    <div class="row mb-4 mx-1 mx-md-0">
        <div class="col-md-6">
            <h2>Shop</h2>
            <p>Browse our collection of authentic football jerseys.</p>
        </div>
        <div class="col-md-6 d-flex justify-content-end align-items-center">
            <div class="me-3">
                <label for="sort-by" class="form-label">Sort by:</label>
                <select class="form-select" id="sort-by" @onchange="ApplyFiltersAndSorting">
                    <option value="default">Default</option>
                    <option value="price-asc">Price: Low to High</option>
                    <option value="price-desc">Price: High to Low</option>
                </select>
            </div>
            <div>
                <label for="filter-by" class="form-label">Filter by:</label>
                <select class="form-select" id="filter-by" @onchange="ApplyFiltersAndSorting">
                    <option value="all">All</option>
                    <option value="Football">Football</option>
                    <option value="Basketball">Basketball</option>
                    <option value="NFL">NFL</option>
                </select>
            </div>
        </div>
    </div>
    @if (pagedProducts is not null)
    {
        @* UPDATED: Changed g-4 to 'g-1 g-md-4'. 
           This makes the gap very small (0.25rem) on mobile and normal (1.5rem) on desktop. *@
        <div class="row g-1 g-md-4">
            @foreach (var product in pagedProducts)
            {
                <div class="col-6 col-lg-4">
                    <ProductCard Product="product" />
                </div>
            }
        </div>
    }
    else
    {
        <p>Loading products...</p>
    }
    <nav aria-label="Page navigation">
        <ul class="pagination justify-content-center mt-4">
            <li class="page-item @(currentPage == 1 ? "disabled" : "")">
                <a class="page-link" href="javascript:void(0)" @onclick="() => ChangePage(currentPage - 1)">Previous</a>
            </li>
            @for (int i = 1; i <= totalPages; i++)
            {
                var pageNumber = i;
                <li class="page-item @(currentPage == pageNumber ? "active" : "")">
                    <a class="page-link" href="javascript:void(0)" @onclick="() => ChangePage(pageNumber)">@pageNumber</a>
                </li>
            }
            <li class="page-item @(currentPage == totalPages ? "disabled" : "")">
                <a class="page-link" href="javascript:void(0)" @onclick="() => ChangePage(currentPage + 1)">Next</a>
            </li>
        </ul>
    </nav>
</div>

@code {
    private List<Product>? allProducts;
    private List<Product>? pagedProducts;
    private List<Product>? processedProducts;
    private int currentPage = 1;
    private int pageSize = 18;
    private int totalPages;
    private string currentSortOrder = "default";
    private string currentCategoryFilter = "all";

    protected override async Task OnInitializedAsync()
    {
        SearchState.OnSearchTermChanged += OnSearchChanged;
        allProducts = await DbContext.Products.ToListAsync();
        if (allProducts is not null)
        {
            ApplyFiltersAndSorting();
        }
    }

    private void OnSearchChanged()
    {
        ApplyFiltersAndSorting();
    }

    private void ApplyFiltersAndSorting(ChangeEventArgs? e = null)
    {
        if (e?.Value is not null)
        {
            var elementId = e.Value.ToString();
            if (e.Value.ToString()!.Contains("price"))
            {
                currentSortOrder = e.Value.ToString()!;
            }
            else
            {
                currentCategoryFilter = e.Value.ToString()!;
            }
        }

        var searchTerm = SearchState.CurrentSearchTerm ?? string.Empty;
        var tempProducts = string.IsNullOrWhiteSpace(searchTerm)
            ? allProducts
            : allProducts?.Where(p =>
                p.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                (p.Category != null && p.Category.Contains(searchTerm, StringComparison.OrdinalIgnoreCase)));

        if (currentCategoryFilter != "all")
        {
            tempProducts = tempProducts?.Where(p => p.Category == currentCategoryFilter);
        }

        switch (currentSortOrder)
        {
            case "price-asc":
                tempProducts = tempProducts?.OrderBy(p => p.Price);
                break;
            case "price-desc":
                tempProducts = tempProducts?.OrderByDescending(p => p.Price);
                break;
        }

        processedProducts = tempProducts?.ToList();

        if (processedProducts is not null)
        {
            totalPages = (int)Math.Ceiling(processedProducts.Count / (double)pageSize);
        }

        currentPage = 1;
        UpdatePagedProducts();
        InvokeAsync(StateHasChanged);
    }

    private void ChangePage(int pageNumber)
    {
        if (pageNumber >= 1 && pageNumber <= totalPages)
        {
            currentPage = pageNumber;
            UpdatePagedProducts();
        }
    }

    private void UpdatePagedProducts()
    {
        if (processedProducts is not null)
        {
            pagedProducts = processedProducts.Skip((currentPage - 1) * pageSize).Take(pageSize).ToList();
        }
    }

    public void Dispose()
    {
        SearchState.OnSearchTermChanged -= OnSearchChanged;
    }
}